<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>iPad Teleprompter Studio</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600&display=swap" rel="stylesheet" />
  <style>
    :root {
      --bg-start: #f0f4ff;
      --bg-end: #ffffff;
      --ink: #0f172a;
      --muted: #53627a;
      --surface: rgba(255, 255, 255, 0.92);
      --surface-soft: rgba(255, 255, 255, 0.65);
      --accent: #f97316;
      --accent-strong: #ea580c;
      --error: #dc2626;
      --border: rgba(15, 23, 42, 0.1);
      --shadow: 0 25px 60px rgba(15, 23, 42, 0.2);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Space Grotesk", sans-serif;
      min-height: 100vh;
      background: linear-gradient(160deg, var(--bg-start), var(--bg-end));
      color: var(--ink);
    }

    .canvas {
      position: relative;
      min-height: 100vh;
      width: 100%;
      overflow: hidden;
    }

    .camera-feed {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .canvas::after {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(180deg, rgba(0, 0, 0, 0.1) 0%, rgba(0, 0, 0, 0.25) 100%);
      pointer-events: none;
    }

    .teleprompter {
      position: absolute;
      top: 6vh;
      left: 50%;
      transform: translateX(-50%);
      width: min(900px, 92%);
      height: 70vh;
      padding: clamp(1.5rem, 3vw, 2.5rem);
      background: var(--surface-soft);
      border-radius: 1.75rem;
      border: 1px solid rgba(255, 255, 255, 0.6);
      box-shadow: var(--shadow);
      overflow: hidden;
      backdrop-filter: blur(18px);
    }

    .teleprompter-inner {
      will-change: transform;
      display: flex;
      flex-direction: column;
      gap: 1.2rem;
      font-size: clamp(1.4rem, 3vw, 2.4rem);
      line-height: 1.4;
      color: var(--ink);
      padding-bottom: 60vh;
    }

    .teleprompter p {
      margin: 0;
    }

    .teleprompter.mirrored {
      transform: translateX(-50%) scaleX(-1);
    }

    .teleprompter.mirrored .teleprompter-inner {
      transform: scaleX(-1);
    }

    .control-dock {
      position: absolute;
      left: 50%;
      bottom: 0;
      transform: translateX(-50%);
      width: min(1100px, 94%);
      background: var(--surface);
      border-radius: 2rem 2rem 0 0;
      box-shadow: var(--shadow);
      padding: 1.75rem clamp(1rem, 4vw, 2.5rem) 2rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      z-index: 2;
      transition: width 200ms ease, padding 200ms ease, border-radius 200ms ease;
    }

    .control-dock.collapsed {
      width: min(420px, 92%);
      padding: 0.75rem 1.5rem 1rem;
      border-radius: 999px 999px 0 0;
      background: rgba(255, 255, 255, 0.85);
      gap: 0.5rem;
    }

    .dock-toggle {
      border: none;
      background: transparent;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--accent-strong);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0;
    }

    .dock-toggle-label {
      font-size: 0.85rem;
    }

    .dock-toggle-icon {
      transition: transform 160ms ease;
      font-size: 1rem;
      margin-left: 0.5rem;
    }

    .control-dock.collapsed .dock-toggle-icon {
      transform: rotate(180deg);
    }

    .dock-body {
      display: flex;
      flex-direction: column;
      gap: 1.2rem;
    }

    .control-dock.collapsed .dock-body {
      display: none;
    }

    .countdown-overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: clamp(4rem, 12vw, 8rem);
      font-weight: 600;
      color: #ffffff;
      text-shadow: 0 15px 45px rgba(15, 23, 42, 0.45);
      opacity: 0;
      pointer-events: none;
      transition: opacity 160ms ease;
      z-index: 3;
    }

    .countdown-overlay.visible {
      opacity: 1;
    }

    .timestamp {
      font-size: 0.9rem;
      color: var(--muted);
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    .status-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 1rem;
      color: var(--ink);
    }

    .badge {
      padding: 0.35rem 1rem;
      border-radius: 999px;
      border: 1px solid var(--border);
    }

    .badge.recording {
      border-color: var(--error);
      color: var(--error);
    }

    .button-row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 0.75rem;
    }

    button,
    .ghost-button {
      border: 1px solid rgba(15, 23, 42, 0.15);
      background: rgba(255, 255, 255, 0.6);
      color: var(--ink);
      font-weight: 600;
      border-radius: 999px;
      padding: 0.85rem 1.1rem;
      font-family: inherit;
      cursor: pointer;
      transition: transform 160ms ease, border-color 160ms ease;
      text-align: center;
      text-decoration: none;
      display: inline-flex;
      justify-content: center;
    }

    button.primary {
      background: var(--accent);
      border-color: var(--accent);
      color: #fff;
    }

    button.danger {
      background: rgba(220, 38, 38, 0.1);
      border-color: rgba(220, 38, 38, 0.4);
      color: var(--error);
    }

    button:disabled,
    .ghost-button.disabled {
      opacity: 0.4;
      cursor: not-allowed;
      pointer-events: none;
    }

    button:hover:not(:disabled),
    .ghost-button:not(.disabled):hover {
      transform: translateY(-1px);
      border-color: var(--accent-strong);
    }

    .layout-split {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
    }

    .script-editor {
      flex: 1 1 320px;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    textarea {
      width: 100%;
      min-height: 300px;
      max-height: 400px;
      border-radius: 1rem;
      border: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.8);
      color: var(--ink);
      padding: 1rem;
      resize: vertical;
      font-size: 1rem;
      font-family: inherit;
      line-height: 1.5;
      box-shadow: inset 0 1px 3px rgba(15, 23, 42, 0.08);
      overflow-y: auto;
    }

    .prompt-controls {
      flex: 1 1 220px;
      display: grid;
      gap: 0.75rem;
    }

    label {
      font-size: 0.85rem;
      color: var(--muted);
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }

    input[type="range"] {
      width: 100%;
    }

    .hint {
      color: var(--muted);
      font-size: 0.95rem;
      margin: 0;
    }

    .recording-timer-overlay {
      position: absolute;
      top: 1.5rem;
      right: 1.5rem;
      display: flex;
      align-items: center;
      gap: 0.6rem;
      padding: 0.6rem 1.2rem;
      background: rgba(0, 0, 0, 0.7);
      border-radius: 999px;
      z-index: 10;
      opacity: 0;
      pointer-events: none;
      transition: opacity 200ms ease;
    }

    .recording-timer-overlay.visible {
      opacity: 1;
    }

    .recording-timer-overlay .rec-dot {
      width: 12px;
      height: 12px;
      background: #ef4444;
      border-radius: 50%;
      animation: pulse-dot 1s ease-in-out infinite;
    }

    @keyframes pulse-dot {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: 0.4;
      }
    }

    .recording-timer-overlay .rec-time {
      font-size: 1.1rem;
      font-weight: 600;
      color: #ffffff;
      font-variant-numeric: tabular-nums;
    }

    @media (max-width: 640px) {
      .teleprompter {
        top: 3vh;
        max-height: 60vh;
      }

      .control-dock {
        border-radius: 1.5rem 1.5rem 0 0;
      }
    }

    /* Preview Modal */
    .preview-modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      opacity: 0;
      pointer-events: none;
      transition: opacity 200ms ease;
    }

    .preview-modal.visible {
      opacity: 1;
      pointer-events: auto;
    }

    .preview-container {
      width: min(90%, 600px);
      background: var(--surface);
      border-radius: 1.5rem;
      overflow: hidden;
      box-shadow: 0 25px 80px rgba(0, 0, 0, 0.5);
    }

    .preview-header {
      padding: 1rem 1.5rem;
      background: rgba(0, 0, 0, 0.1);
      font-weight: 600;
      font-size: 1.1rem;
      text-align: center;
    }

    .preview-video-wrap {
      position: relative;
      width: 100%;
      aspect-ratio: 16 / 9;
      background: #000;
    }

    .preview-video-wrap video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .preview-script {
      padding: 1rem 1.5rem;
      max-height: 120px;
      overflow-y: auto;
      font-size: 0.95rem;
      color: var(--muted);
      background: rgba(0, 0, 0, 0.05);
      border-top: 1px solid var(--border);
    }

    .preview-script strong {
      color: var(--ink);
    }

    .preview-buttons {
      display: flex;
      gap: 0.75rem;
      padding: 1rem 1.5rem;
    }

    .preview-buttons button {
      flex: 1;
    }

    /* Small camera preview (picture-in-picture) in dock */
    .pip-camera {
      width: 160px;
      height: 90px;
      border-radius: 0.75rem;
      overflow: hidden;
      background: #000;
      border: 2px solid var(--accent);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    .pip-camera video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .pip-camera.hidden {
      display: none;
    }

    .status-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 1rem;
      color: var(--ink);
      gap: 1rem;
    }
  </style>
</head>

<body>
  <div class="canvas">
    <video id="cameraPreview" class="camera-feed" autoplay playsinline muted></video>

    <!-- Recording timer overlay -->
    <div class="recording-timer-overlay" id="recordingTimerOverlay">
      <span class="rec-dot"></span>
      <span class="rec-time" id="recTime">00:00</span>
    </div>

    <div class="teleprompter" id="teleprompter">
      <div class="teleprompter-inner" id="teleprompterText"></div>
    </div>

    <div class="countdown-overlay" id="countdown"></div>

    <div class="control-dock collapsed" id="controlDock">
      <button class="dock-toggle" id="dockToggle" aria-expanded="false">
        <span class="dock-toggle-label">Show controls</span>
        <span class="dock-toggle-icon" aria-hidden="true">â–´</span>
      </button>
      <div class="dock-body">
        <div class="timestamp">Teleprompter Studio Â· Last refreshed: <span id="timestamp">â€”</span></div>
        <div class="status-bar">
          <span>Timer: <strong id="timer">00:00</strong></span>
          <!-- Small camera preview -->
          <div class="pip-camera hidden" id="pipCamera">
            <video id="pipVideo" autoplay playsinline muted></video>
          </div>
          <span class="badge" id="statusBadge">Standby</span>
        </div>
        <div class="button-row">
          <button id="startCamera" class="primary">Start camera</button>
          <button id="flipCamera">Flip camera</button>
          <button id="recordBtn" class="primary" disabled>Start recording</button>
          <button id="stopRecordBtn" class="danger" disabled>Stop recording</button>
          <a id="downloadRecording" class="ghost-button disabled" role="button" aria-disabled="true">Download clip</a>
        </div>
        <div class="layout-split">
          <div class="script-editor">
            <label for="scriptInput">Script text
              <textarea id="scriptInput" spellcheck="false">Hey everyone,

Thanks for tuning in today. I wanted to share a quick update straight from the iPad teleprompter I built.

Remember to smile, slow down, and keep your energy up!</textarea>
            </label>
          </div>
          <div class="prompt-controls">
            <button id="toggleScroll" class="primary">Play scroll</button>
            <button id="resetScroll">Reset</button>
            <button id="mirrorToggle">Mirror text</button>
            <label>Speed
              <input id="speed" type="range" min="0.1" max="4" step="0.1" value="1" />
            </label>
          </div>
        </div>
        <p class="hint">
          Run this page fullscreen on the iPad, dim the screen slightly, and keep your gaze near the lens for natural
          eye contact.
        </p>
      </div>
    </div>
  </div>

  <!-- Preview Modal -->
  <div class="preview-modal" id="previewModal">
    <div class="preview-container">
      <div class="preview-header">ðŸ“¹ Camera Preview</div>
      <div class="preview-video-wrap">
        <video id="previewVideo" autoplay playsinline muted></video>
      </div>
      <div class="preview-script" id="previewScript">
        <strong>Script:</strong> <span id="previewScriptText"></span>
      </div>
      <div class="preview-buttons">
        <button id="cancelPreview">Cancel</button>
        <button id="confirmRecord" class="primary">âœ“ Go Full Screen</button>
      </div>
    </div>
  </div>

  <script>
    const scriptInput = document.getElementById('scriptInput');
    const teleprompter = document.getElementById('teleprompter');
    const teleprompterText = document.getElementById('teleprompterText');
    const toggleScrollBtn = document.getElementById('toggleScroll');
    const resetScrollBtn = document.getElementById('resetScroll');
    const mirrorToggleBtn = document.getElementById('mirrorToggle');
    const speedInput = document.getElementById('speed');
    const timestamp = document.getElementById('timestamp');
    const countdownEl = document.getElementById('countdown');
    const dock = document.getElementById('controlDock');
    const dockToggle = document.getElementById('dockToggle');
    const dockToggleLabel = dockToggle.querySelector('.dock-toggle-label');

    let scrollPosition = 0;
    let isScrolling = false;
    let lastFrameTime = 0;
    let countdownActive = false;
    let dockAutoCollapsed = false;

    const wait = ms => new Promise(resolve => setTimeout(resolve, ms));

    const renderScript = () => {
      const lines = scriptInput.value.trim().split(/\n+/).filter(Boolean);
      teleprompterText.innerHTML = lines.map(line => `<p>${line}</p>`).join('');
      scrollPosition = 0;
      teleprompterText.style.transform = 'translateY(0)';
    };

    const setDockExpanded = expanded => {
      if (expanded) {
        dock.classList.remove('collapsed');
      } else {
        dock.classList.add('collapsed');
      }
      dockToggleLabel.textContent = expanded ? 'Hide controls' : 'Show controls';
      dockToggle.setAttribute('aria-expanded', expanded ? 'true' : 'false');
    };

    setDockExpanded(true);

    dockToggle.addEventListener('click', () => {
      const expanded = dock.classList.contains('collapsed');
      setDockExpanded(expanded);
      dockAutoCollapsed = false;
    });

    const runCountdown = async () => {
      countdownActive = true;
      countdownEl.classList.add('visible');
      const sequence = ['3', '2', '1'];
      for (const value of sequence) {
        countdownEl.textContent = value;
        await wait(800);
      }
      countdownEl.textContent = 'Go!';
      await wait(400);
      countdownEl.classList.remove('visible');
      countdownActive = false;
    };

    const animateScroll = time => {
      if (isScrolling) {
        if (lastFrameTime) {
          const delta = time - lastFrameTime;
          const pixelsPerFrame = parseFloat(speedInput.value) * 0.4 * (delta / 16);
          scrollPosition += pixelsPerFrame;
          const maxScroll = Math.max(0, teleprompterText.offsetHeight - teleprompter.offsetHeight);
          if (scrollPosition >= maxScroll) {
            scrollPosition = maxScroll;
            isScrolling = false;
            toggleScrollBtn.textContent = 'Play scroll';
          }
        }
        teleprompterText.style.transform = `translateY(${-scrollPosition}px)`;
      }
      lastFrameTime = time;
      requestAnimationFrame(animateScroll);
    };

    toggleScrollBtn.addEventListener('click', () => {
      isScrolling = !isScrolling;
      toggleScrollBtn.textContent = isScrolling ? 'Pause scroll' : 'Play scroll';
      if (!isScrolling) {
        lastFrameTime = 0;
      }
    });

    resetScrollBtn.addEventListener('click', () => {
      scrollPosition = 0;
      teleprompterText.style.transform = 'translateY(0)';
      isScrolling = false;
      toggleScrollBtn.textContent = 'Play scroll';
    });

    mirrorToggleBtn.addEventListener('click', () => {
      teleprompter.classList.toggle('mirrored');
      mirrorToggleBtn.textContent = teleprompter.classList.contains('mirrored') ? 'Unmirror text' : 'Mirror text';
    });

    scriptInput.addEventListener('input', () => {
      renderScript();
    });

    renderScript();
    requestAnimationFrame(animateScroll);
    timestamp.textContent = new Date().toLocaleString();

    // Camera + recording setup
    const preview = document.getElementById('cameraPreview');
    const startCameraBtn = document.getElementById('startCamera');
    const flipCameraBtn = document.getElementById('flipCamera');
    const recordBtn = document.getElementById('recordBtn');
    const stopRecordBtn = document.getElementById('stopRecordBtn');
    const downloadBtn = document.getElementById('downloadRecording');
    const statusBadge = document.getElementById('statusBadge');
    const timerEl = document.getElementById('timer');

    let stream;
    let recorder;
    let recordedChunks = [];
    let facingMode = 'user';
    let mimeType = '';
    let timerInterval;
    let startTime = null;

    const updateStatus = (text, state) => {
      statusBadge.textContent = text;
      statusBadge.classList.remove('recording');
      if (state === 'recording') {
        statusBadge.classList.add('recording');
      }
    };

    const setDownloadEnabled = enabled => {
      if (enabled) {
        downloadBtn.classList.remove('disabled');
        downloadBtn.setAttribute('aria-disabled', 'false');
      } else {
        downloadBtn.classList.add('disabled');
        downloadBtn.setAttribute('aria-disabled', 'true');
        downloadBtn.removeAttribute('href');
        downloadBtn.removeAttribute('download');
      }
    };

    const stopTracks = () => {
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
        stream = null;
      }
    };

    const initCamera = async () => {
      try {
        stopTracks();
        stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode },
          audio: true,
        });
        // Show in small preview modal first
        previewVideo.srcObject = stream;
        previewScriptText.textContent = scriptInput.value.trim().substring(0, 200) + (scriptInput.value.length > 200 ? '...' : '');
        previewModal.classList.add('visible');
        recordBtn.disabled = true;
        flipCameraBtn.disabled = false;
        updateStatus('Preview mode');
      } catch (err) {
        console.error(err);
        updateStatus('Camera blocked', 'error');
        alert('Please allow camera + microphone access in Safari settings.');
      }
    };

    const formatTime = ms => {
      const total = Math.floor(ms / 1000);
      const minutes = String(Math.floor(total / 60)).padStart(2, '0');
      const seconds = String(total % 60).padStart(2, '0');
      return `${minutes}:${seconds}`;
    };

    const recTimeOverlay = document.getElementById('recTime');
    const recordingTimerOverlay = document.getElementById('recordingTimerOverlay');

    const startTimer = () => {
      startTime = Date.now();
      timerEl.textContent = '00:00';
      recTimeOverlay.textContent = '00:00';
      recordingTimerOverlay.classList.add('visible');
      timerInterval = setInterval(() => {
        const elapsed = formatTime(Date.now() - startTime);
        timerEl.textContent = elapsed;
        recTimeOverlay.textContent = elapsed;
      }, 200);
    };

    const stopTimer = () => {
      clearInterval(timerInterval);
      timerInterval = null;
      recordingTimerOverlay.classList.remove('visible');
    };

    startCameraBtn.addEventListener('click', initCamera);

    flipCameraBtn.addEventListener('click', () => {
      facingMode = facingMode === 'user' ? 'environment' : 'user';
      initCamera();
    });

    const pickMimeType = () => {
      const mp4 = 'video/mp4;codecs="h264,aac"';
      const webm = 'video/webm;codecs=vp9,opus';
      if (MediaRecorder.isTypeSupported(mp4)) {
        return mp4;
      }
      if (MediaRecorder.isTypeSupported(webm)) {
        return webm;
      }
      return '';
    };

    // Preview modal elements
    const previewModal = document.getElementById('previewModal');
    const previewVideo = document.getElementById('previewVideo');
    const previewScriptText = document.getElementById('previewScriptText');
    const cancelPreviewBtn = document.getElementById('cancelPreview');
    const confirmRecordBtn = document.getElementById('confirmRecord');

    // Small pip camera in dock
    const pipCamera = document.getElementById('pipCamera');
    const pipVideo = document.getElementById('pipVideo');

    const showPreviewModal = () => {
      previewVideo.srcObject = stream;
      previewScriptText.textContent = scriptInput.value.trim().substring(0, 200) + (scriptInput.value.length > 200 ? '...' : '');
      previewModal.classList.add('visible');
    };

    const hidePreviewModal = () => {
      previewModal.classList.remove('visible');
    };

    const goFullScreen = () => {
      // Move stream to main preview and pip camera
      preview.srcObject = stream;
      pipVideo.srcObject = stream;
      pipCamera.classList.remove('hidden');
      previewVideo.srcObject = null;
      hidePreviewModal();
      recordBtn.disabled = false;
      updateStatus('Camera live');
    };

    cancelPreviewBtn.addEventListener('click', () => {
      hidePreviewModal();
      // Stop camera if user cancels
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
        stream = null;
      }
      preview.srcObject = null;
      previewVideo.srcObject = null;
      pipVideo.srcObject = null;
      pipCamera.classList.add('hidden');
      recordBtn.disabled = true;
      updateStatus('Standby');
    });

    // Confirm button now goes to full screen view
    confirmRecordBtn.addEventListener('click', goFullScreen);

    recordBtn.addEventListener('click', async () => {
      if (!stream) {
        alert('Start the camera first.');
        return;
      }
      if (countdownActive) {
        return;
      }

      mimeType = pickMimeType();
      try {
        recorder = new MediaRecorder(stream, mimeType ? { mimeType } : undefined);
      } catch (err) {
        console.error(err);
        alert('Recording not supported in this browser.');
        return;
      }
      recordedChunks = [];
      recorder.ondataavailable = e => {
        if (e.data?.size) {
          recordedChunks.push(e.data);
        }
      };
      recorder.onstop = () => {
        if (!recordedChunks.length) {
          setDownloadEnabled(false);
          if (dockAutoCollapsed) {
            setDockExpanded(true);
            dockAutoCollapsed = false;
          }
          return;
        }
        const blob = new Blob(recordedChunks, { type: mimeType || 'video/webm' });
        const url = URL.createObjectURL(blob);
        downloadBtn.href = url;
        const extension = (mimeType && mimeType.includes('mp4')) ? 'mp4' : 'webm';
        downloadBtn.download = `teleprompter-${Date.now()}.${extension}`;
        setDownloadEnabled(true);
        updateStatus('Ready to download');
        if (dockAutoCollapsed) {
          setDockExpanded(true);
          dockAutoCollapsed = false;
        }
      };
      recordBtn.disabled = true;
      stopRecordBtn.disabled = true;
      setDownloadEnabled(false);
      updateStatus('Get ready');
      const wasCollapsed = dock.classList.contains('collapsed');
      dockAutoCollapsed = !wasCollapsed;
      setDockExpanded(false);
      await runCountdown();
      recorder.start();
      startTimer();
      // Auto-start teleprompter scroll when recording begins
      scrollPosition = 0;
      teleprompterText.style.transform = 'translateY(0)';
      isScrolling = true;
      toggleScrollBtn.textContent = 'Pause scroll';
      updateStatus('Recording', 'recording');
      stopRecordBtn.disabled = false;
    });

    stopRecordBtn.addEventListener('click', () => {
      if (recorder && recorder.state !== 'inactive') {
        recorder.stop();
      }
      stopTimer();
      // Stop teleprompter scroll when recording stops
      isScrolling = false;
      toggleScrollBtn.textContent = 'Play scroll';
      recordBtn.disabled = false;
      stopRecordBtn.disabled = true;
      setDownloadEnabled(false);
      updateStatus('Processing clip');
    });

    downloadBtn.addEventListener('click', () => {
      if (!downloadBtn.classList.contains('disabled')) {
        updateStatus('Clip saved');
      }
    });

    window.addEventListener('beforeunload', () => {
      stopTracks();
    });
  </script>
</body>

</html>
